
# TODO:
# https://www.stardog.com/tutorials/sparql/
# Complete the series below with examples from the following links:
# https://www.stardog.com/tutorials/getting-started-1/
# https://www.stardog.com/tutorials/similarity-search/
# https://www.w3.org/TR/2013/REC-sparql11-query-20130321/#idp899488


# Basic select with specified columns
# Query 1: Employee names 
SELECT
# ?emp
  ?label
  ?lastName
  ?firstName
  ?title
WHERE {
  ?emp a :employee ;
         rdfs:label ?label ;
         foaf:title ?title ;
         foaf:lastName ?lastName ;
         foaf:firstName ?firstName .
         
}


# Filtering Data
# Query 2: List of Employees in the USA
SELECT
  ?emp
  ?label
  ?lastName
  ?firstName
  ?title
WHERE {
  ?emp a :employee ;
         rdfs:label ?label ;
         foaf:lastName ?lastName ;
         foaf:firstName ?firstName ;
         foaf:title ?title ;
         :country ?country .
  FILTER(?country = "USA")
}

# Note: The same filter can be applied directly as follows
SELECT
  #?emp
  #?label
  ?lastName
  ?firstName
  ?title
WHERE {
  ?emp a :employee ;
         rdfs:label ?label ;
         foaf:lastName ?lastName ;
         foaf:firstName ?firstName ;
         foaf:title ?title ;
         :country "USA" .
}


# Returns a boolean indicating whether a query pattern matches or not.
# Query 3: Do I have any employees in the USA?
ASK {
  ?emp a :employee ;
         :country "USA" .
}


# Character search pattern (Regex)
# Query 4: Companies that contain the word "rest" in their names.
SELECT
  ?s # This object variable can be used to visualize the graph in Stardog Studio
  ?companyLabel
  ?companyName
  ?contactName
  ?address
  ?city 
  ?phone 
WHERE {
  ?s a :customer ;
       rdfs:label ?companyLabel ;
       :companyName ?companyName ;
       :contactName ?contactName ;
       :address ?address ;
       :city ?city ;
       :phone ?phone .
  FILTER (REGEX(?companyName, "Rest" , "i" )) # Case Insensitive
}


# Joins
# Query 5: Selecting details of products supplied in the USA
SELECT 
  ?productID 
  ?productName 
  ?unitsInStock 
  ?unitPrice 
  ?categoryName 
  ?contactName
WHERE
{ 
  ?product a  :product ;
              :productID ?productID ;
              :productName ?productName ;
              :unitsInStock ?unitsInStock ;
              :unitPrice ?unitPrice ;
              rdfs:label ?productLabel ;
              :hasCategory ?category ;
              :hasSupplier ?supplier .
  ?category a :category ;
              :name ?categoryName .
  ?supplier a :supplier ;
              :contactName ?contactName ;
              :country "USA" .
} 


# Logical Operators
# Query 6: Spedific list of products and their suppliers details
SELECT
  ?productName
  (STR(?unitPrice) AS ?strUnitPrice) # converting integer to string
  ?supplierName
  ?region 
  ?country 
WHERE {
  ?s a :product ;
       :productName ?productName ;
       :productID ?productID ;
       :hasSupplier ?supplier ; # Joining on supplier
       :unitPrice ?unitPrice . 
  # getting supplier properties
  ?supplier :companyName ?supplierName ;  
            :country ?country ; 
  OPTIONAL {?supplier  :region ?region }. # not all suppliers have region
  FILTER((REGEX(?productName, "^T", "i") || ?productID = 46) && ?unitPrice > 16) . # Logical operators
}


# Filtering on Data ranges
# Query 7: Products in specified price range
SELECT
  ?productID
  ?productName
  ?supplierID
  ?companyName
  ?unitPrice
WHERE {
  ?s a :product ;
       :productID ?productID ;
       :productName ?productName ;
       :hasSupplier ?supplier ; 
       :unitPrice ?unitPrice .
  ?supplier a :supplier ;
       :companyName ?companyName ;
       :supplierID ?supplierID .
  FILTER (?unitPrice >= 18 && ?unitPrice <= 20)
}


# Filtering on list of values
# Query 8: Suppliers in Japan and Italy
SELECT
  ?companyName
  ?country
WHERE {
  ?s a :supplier ;
       :companyName ?companyName ;
       :country ?country .
  FILTER (UCASE(?country) = "JAPAN" || ?country = "Italy") # case sensitive
}


# Working with Nulls (next 3 examples)
# Fax was a machine from the 90s able to scan and transmit a document over the phone line.

# Query 9a: Select only suppliers that have a fax number
SELECT
  ?companyName
  ?fax
WHERE {
  ?s a :supplier ;
       :companyName ?companyName ;
       :fax ?fax . 
}


# Query 9b: Select all suppliers
SELECT
  ?companyName
  ?fax
WHERE {
  ?s a :supplier ;
       :companyName ?companyName ;
       OPTIONAL {?s :fax ?fax} . 
}


# Query 9c: Select only suppliers that don't have a fax number
SELECT
  ?companyName
  ?fax
WHERE {
  ?s a :supplier ;
       :companyName ?companyName ;
       OPTIONAL {?s :fax ?fax} . 
  FILTER (!BOUND(?fax))
}


# Sorting data
# Query 10: Select product details sorted by category name and unit price
SELECT
  ?productID
  ?productName
  ?categoryName
  ?unitPrice
WHERE {
  ?s a :product ;
       :productID ?productID ;
       :productName ?productName ;
       :unitPrice ?unitPrice ;
       :hasCategory ?category .
  ?category :name ?categoryName . 
}
ORDER BY 
  ASC(?categoryName)
  DESC(?unitPrice)


# Eliminating duplicates
# Query 11: Select all countries I buy from
# There are more than one supplier per country
SELECT DISTINCT ?country
WHERE{
  ?s a :supplier ;
       :country ?country .
}
ORDER BY ?country # Default sorting


# Column alias and string concatenation
# Query 12: Create employee code
SELECT
  (?employeeLabel AS ?label)
  ?firstName
  ?lastName
  (?employeeCode AS ?code)
 WHERE {
   ?s a :employee ;
        foaf:firstName ?firstName ;
        foaf:lastName ?lastName ;
        rdfs:label ?employeeLabel ; 
  BIND(CONCAT(?employeeLabel, "-", SUBSTR(?firstName,1,1), SUBSTR(?lastName,1,3)) AS ?employeeCode)
 }


# Limiting results
# Query 13: Top 10 largest orders of a single product
SELECT
    ?orderID
    ?orderDate
    ?quantity
    ?unitPrice
    ?productName
    ?unitsInStock
    ?unitsOnOrder
WHERE {
  ?orderDetail  a :orderDetail .
  ?order        a :order .
  ?product      a :product .
  ?orderDetail    :quantity         ?quantity ;
                  :belongsToOrder   ?order ;
                  :hasProduct       ?product ;
                  :unitPrice        ?unitPrice .
  ?order          :orderID          ?orderID ;
                  :orderDate        ?orderDate .
  ?product        :unitsInStock     ?unitsInStock ;
                  :unitsOnOrder     ?unitsOnOrder ;
                  :productName      ?productName .
}
ORDER BY 
  DESC(?quantity)
  DESC(?orderDate)
LIMIT 10


# Counting
# Query 14: Number of supplier. 
SELECT (COUNT(1) AS ?supplierCount)
WHERE{
  ?s a :supplier .
}


# Distinct Counting
# Query 15: Number of countries I buy from.
SELECT (COUNT(DISTINCT ?country) AS ?countryCount)
WHERE{
  ?s a :supplier ;
       :country ?country .
}


# Grouping and Aggregating data
# Query 16a: Top 10 most sold products
SELECT
  ?prd
  (SUM(?quantity) AS ?totalQtySold)  
WHERE {
  ?od a :orderDetail ;
        :quantity ?quantity ;
        :hasProduct ?prd .
}
GROUP BY ?prd
ORDER BY DESC(?totalQtySold)
LIMIT 10


# Query 16b: Top 5 largest orders shipped to the USA
SELECT
  ?orderID
  (SUM(?unitPrice * ?quantity * (1 - ?discount)) AS ?total) 
WHERE {
  ?order        a :order ;
                  :orderID ?orderID ;
                  :shipCountry "USA" .
  ?orderDetail  a :orderDetail ;
                  :belongsToOrder ?order ;
                  :unitPrice ?unitPrice ;
                  :quantity ?quantity ;
                  :discount ?discount .
}
GROUP BY
  ?orderID
ORDER BY 
  DESC(?total)
LIMIT 5


# Query 16c: Orders shipped to the USA with amount over 8K
SELECT
  ?orderID
  (SUM(?unitPrice * ?quantity * (1 - ?discount)) AS ?total) 
WHERE {
  ?order        a :order ;
                  :orderID ?orderID ;
                  :shipCountry "USA" .
  ?orderDetail  a :orderDetail ;
                  :belongsToOrder ?order ;
                  :unitPrice ?unitPrice ;
                  :quantity ?quantity ;
                  :discount ?discount .
}
GROUP BY
  ?orderID
HAVING (SUM(?unitPrice * ?quantity * (1 - ?discount)) > 8000)
ORDER BY 
  DESC(?total)


# Query 16d: Quantity of products sold by each Supplier Representative 
SELECT 
  ?supplierContactName 
  (COUNT(?product) as ?productCount)
WHERE
{ 
  ?product a  :product ;
              :hasSupplier ?supplier .
  ?supplier a :supplier ;
              :contactName ?supplierContactName .
  #FILTER(?supplierContactName = "Charlotte Cooper") .
} 
GROUP BY 
  ?supplierContactName
HAVING 
  (COUNT(?product) >= 3) # minimum of 3 products
ORDER BY
  DESC(?productCount)



# Recommendation - Products frequently bought together (Queries 17, 18 and 19)

# Query 17: Number of times products 2 and 61 where bought by the same customer
SELECT (COUNT (1) AS ?Count)
WHERE {:product-2 ^:hasProduct/:belongsToOrder/:hasCustomer/^(^:hasProduct/:belongsToOrder/:hasCustomer) :product-61}


# Here are the detailed steps to develop Query 17.
# For more details on Property Path, please refer to https://www.stardog.com/tutorials/sparql/#toc7.
# Triple pattern matching order, orderDetail, product and customer nodes that are directly connected. 
# List order items that contain product-61
SELECT *
WHERE {
  ?orderDetail :hasProduct ?product ; 
               :belongsToOrder ?order .
  ?order       :hasCustomer ?customer .
  FILTER (?product = :product-61)
}

# Invert the hasProduct path expression to match the following direction: product --> orderDetail --> order --> customer
# The same result is returned
SELECT *
WHERE {
  ?product     ^:hasProduct  ?orderDetail . # Invert direction
  ?orderDetail :belongsToOrder ?order .
  ?order       :hasCustomer ?customer .
  FILTER (?product = :product-61)
}

# Use a sequence path to omit the binding of the ?orderDetail variable.  
SELECT *
WHERE {
  ?product ^:hasProduct/:belongsToOrder ?order .
  ?order   :hasCustomer ?customer .
  FILTER (?product = :product-61)
}

# And then again, to omit the binding of the ?order varaible.
# All customers that bought product-61
SELECT DISTINCT * # eliminates duplicates in case the same customer bouth a product more than once
WHERE {
  ?product ^:hasProduct/:belongsToOrder/:hasCustomer ?customer .
  FILTER (?product = :product-61)
}
ORDER BY ?product

# Remove the ?product variable and apply the filter directly to the subject. 
SELECT DISTINCT * # eliminates duplicates in case the same customer bouth a product more than once
WHERE {
  :product-61 ^:hasProduct/:belongsToOrder/:hasCustomer ?customer .
}
ORDER BY ?product

# And finally, omit the binding of the ?customer varaible and add the path back to product.  
SELECT (COUNT (1) AS ?Count)
WHERE {:product-2 ^:hasProduct/:belongsToOrder/:hasCustomer/^(^:hasProduct/:belongsToOrder/:hasCustomer) :product-61}


# Query 18: Customers who bought product-61 also bought which products across all orders?
SELECT 
  ?productA
  ?productB
  (COUNT (*) AS ?productBCount)
WHERE {
  ?productA ^:hasProduct/:belongsToOrder/:hasCustomer/^(^:hasProduct/:belongsToOrder/:hasCustomer) ?productB ;
            :productID ?productID .
  FILTER (?productA != ?productB && ?productA = :product-61) # Filtering on product-61 for testing purposes
}
GROUP BY ?productA ?productB
ORDER BY DESC(?productBCount) ?productA ?productB
LIMIT 5


# Query 19: Most frequent products bought together. 
# Customers who bought product-61 also bought which products in the same order?
SELECT 
  ?productA
  ?productB
  (COUNT (*) AS ?productBCount)
WHERE {
  ?productA ^:hasProduct/:belongsToOrder/^(^:hasProduct/:belongsToOrder) ?productB ;
             :productID ?productID .
  FILTER (?productA != ?productB && ?productA = :product-61) # Filtering on product-61 for testing
}
GROUP BY ?productA ?productB 
ORDER BY DESC(?productBCount) ?productA ?productB # Most frequent at the top
LIMIT 5


# Insert a new customer

# Looking at triples of an existing customer for reference
# Class
<http://www.mysparql.com/resource/northwind/customer> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://www.w3.org/2000/01/rdf-schema#Class> .
# Instance
<http://www.mysparql.com/resource/northwind/customer-ALFKI> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://www.mysparql.com/resource/northwind/customer> .
# Properties
<http://www.mysparql.com/resource/northwind/customer-ALFKI> <http://www.mysparql.com/resource/northwind/fax> "030-0076545" .
<http://www.mysparql.com/resource/northwind/customer-ALFKI> <http://www.mysparql.com/resource/northwind/address> "Obere Str. 57" .
<http://www.mysparql.com/resource/northwind/customer-ALFKI> <http://www.mysparql.com/resource/northwind/phone> "030-0074321" .
<http://www.mysparql.com/resource/northwind/customer-ALFKI> <http://www.w3.org/2000/01/rdf-schema#label> "customer-ALFKI" .
<http://www.mysparql.com/resource/northwind/customer-ALFKI> <http://www.mysparql.com/resource/northwind/city> "Berlin" .
<http://www.mysparql.com/resource/northwind/customer-ALFKI> <http://www.mysparql.com/resource/northwind/contactTitle> "Sales Representative" .
<http://www.mysparql.com/resource/northwind/customer-ALFKI> <http://www.mysparql.com/resource/northwind/companyName> "Alfreds Futterkiste" .
<http://www.mysparql.com/resource/northwind/customer-ALFKI> <http://www.mysparql.com/resource/northwind/country> "Germany" .
<http://www.mysparql.com/resource/northwind/customer-ALFKI> <http://www.mysparql.com/resource/northwind/postalCode> "12209" .
<http://www.mysparql.com/resource/northwind/customer-ALFKI> <http://www.mysparql.com/resource/northwind/customerID> "ALFKI" .
<http://www.mysparql.com/resource/northwind/customer-ALFKI> <http://www.mysparql.com/resource/northwind/contactName> "Maria Anders" .
# Linking customer to an order 
<http://www.mysparql.com/resource/northwind/order-10643> <http://www.mysparql.com/resource/northwind/hasCustomer> <http://www.mysparql.com/resource/northwind/customer-ALFKI> .
# The following will not be covered:
# order Properties
# Linking an order to orderDetail
# orderDetail Properties


# Query 20: Insert a new customer
INSERT DATA {
  :customer-AAAAA a :customer ;
  rdfs:label "customer-AAAAA" ;
  :customerID "AAAAA" ;
  :companyName "agnos" ;
  :contactName "Jacobus Geluk" ;
  :contactTitle "CTO" ;
  :address "Abbey Road" ;
  :city "London" .
}


# Checking if new customer has been inserted successfully
DESCRIBE :customer-AAAAA     

# Query 21: Select new added customer
SELECT
  *
WHERE {
  ?s a :customer ;
       rdfs:label ?companyLabel ;
       :companyName ?companyName ;
       :contactName ?contactName ;
       :contactTitle ?contactTitle;
       :address ?address ;
       :city ?city .
       # need to specify optional to match patterns for nodes that may not exist. 
       OPTIONAL {?s :phone ?phone}
       OPTIONAL {?s :fax ?fax}
       OPTIONAL {?s :region ?region}
       OPTIONAL {?s :country ?country}
       OPTIONAL {?s :postalCode ?postalCode}   
  FILTER (?s = :customer-AAAAA)    
}
ORDER BY ?s 
#LIMIT 1 # Could be used if there was an incremental ID

# Country and Postal Code should be mandatory and constraints wil be added to enforced this rule later. 
# Let's update the customer with the required information.
# Query 22a: Add new triples to existing customer
INSERT DATA {
  :customer-AAAAA a :customer ;
  :country "United Kingdom" ;
  :portalCode "SW1A 2AA" . 
}

# There was a spelling mistake in the property name of the insert above. 
# "portalCode" was inserted instead of "postalCode".
# The wrong entry will be fixed in the next steps.

# Checking the property to be deleted.
CONSTRUCT {
  ?s :portalCode ?portalCode
}
WHERE {
  ?s a :customer ;
       rdfs:label "customer-AAAAA" ;
       :portalCode ?portalCode        
}

# You can use the result of the construct above or just do a straight delete as per below. 
# It will not return an error if a triple doesn't exist.
DELETE DATA
{
  :customer-AAAAA :portalCode "SW1A 2AA" .
}

# Checking if the triple went away. 
SELECT DISTINCT
  ?domain ?prop ?range
WHERE {
    ?subject ?prop ?object .
    ?subject a ?domain .
    optional {
        ?object a ?oClass .
    }
    BIND(IF(bound(?oClass), ?oClass, DATATYPE(?object)) AS ?range)
    FILTER (?prop != rdf:type && ?prop != rdfs:domain && ?prop != rdfs:range && ?domain = :customer)
}

# Insert the correct data
INSERT DATA {
  :customer-AAAAA a :customer ;
  :postalCode "SW1A 2AA" . 
}


# Checking how triple for new address will look like.
CONSTRUCT {
:customer-AAAAA :address ?newAddress .
:customer-AAAAA :OldAddress ?OldAddress .
:customer-AAAAA :region "hard-code" . # You can also hard code triples in the construct. 
}
WHERE {
   :customer-AAAAA a :customer ;
     :address ?OldAddress ;
     BIND("10 Downing Road" AS ?newAddress) .
}


# Update Address of customer-AAAAA
# Query 22b: Update existing customer address
DELETE {
:customer-AAAAA :address ?oldAddress 
}
INSERT {
  :customer-AAAAA :address ?newAddress
}
WHERE {
   :customer-AAAAA a :customer ;
     :address ?oldAddress ;
     BIND("10 Downing Road" AS ?newAddress) .
}


# Query 23: Checking number of Customers and Orders
SELECT (COUNT(1) AS ?count) WHERE {?custormer a :customer} # 92
SELECT (COUNT(1) AS ?count) WHERE {?order a :order } # 830


# Query 24: Customers who placed at least one order: 89 Customers
SELECT DISTINCT 
  ?customer
  ?companyName
  ?postalCode
  ?city
  ?country 
WHERE {
  ?order    a :order .
  ?customer a :customer .
  ?order      :hasCustomer ?customer .
  ?customer   :customerID ?customerID ;
              :companyName ?companyName ;
              :city ?city ;
              :country ?country .
  OPTIONAL {?customer :postalCode ?postalCode} . # Some regions don't use PostalCode.
}
ORDER BY
  ?customer


# Query 25: Customers who never placed an order
SELECT DISTINCT 
  ?customer
  ?companyName
  ?postalCode
  ?city
  ?country
WHERE {
  ?customer a :customer .
  ?customer   :customerID ?customerID ;
              :companyName ?companyName ;
              :city ?city ;
              :country ?country .
  OPTIONAL {?customer :postalCode ?postalCode} . # Some regions don't use PostalCode.
  OPTIONAL {
    ?order a  :order .
    ?customer ^:hasCustomer ?order # left join - for customers with no orders, ?order variable will be empty.
  } 
  FILTER (!BOUND(?order)) # Checks if variable is not bound to a value. 
}
ORDER BY
  ?customer


# Subqueries
# Query 26: Select the two most recent orders of each customer
SELECT DISTINCT 
  # from outer query
  ?customerID 
  ?city
  # from inner query
  ?orderID
  ?orderDate
WHERE {
  # outer query
  ?customer a :customer ;
          :customerID ?customerID ;
          :city ?city ;
          ^:hasCustomer ?order .
  { # inner query
    SELECT
        ?orderID
        ?orderDate
    WHERE {
      ?order :hasCustomer ?customer ; # pass the ?order in for each order of the outer query
             :orderID ?orderID ;
             :orderDate ?orderDate .
    }
      ORDER BY
        DESC(?orderDate)
      LIMIT 2
    }
  }
ORDER BY
  ?customerID ?city DESC(?orderDate)


# Union
# Query 27: Contact details of suppliers, customers and employees to send Xmas cards.
SELECT
  ?contactName
  ?address
  ?city
  ?postalCode
  ?country
WHERE {
  {
    ?supplier a :supplier ;
      :contactName ?contactName ;
      :address ?address ;
      :city ?city ;
      :postalCode ?postalCode ;
      :country ?country .
  }
  UNION
  {
    ?customer a :customer ;
      :contactName ?contactName ;
      :address ?address ;
      :city ?city ;
      :postalCode ?postalCode ;
      :country ?country .
  }
   UNION
  {
    ?employee a :employee ;
      foaf:firstName ?firstName ;
      foaf:lastName ?lastName ;
      :address ?address ;
      :city ?city ;
      :postalCode ?postalCode ;
      :country ?country .
    BIND (CONCAT (?firstName, " ", ?lastName) AS ?contactName)
  }
}


# Running Totals
# Query 25: 




# SHACL 
# Inserts that break SHACK constraints
# Power BI
# ontotext GraphDB
# Hierarquical data
# Running totals
# Property Path
# Examples in https://www.w3.org/TR/sparql11-query/#OptionalMatching
# RDF*
# Importing data from virtual graph
# Temporal Data
# OWL
# ETL
# Federated query
# Pth queries - need to find useful use cases in northwind
# PIVOT and UNPIVOT data (tabular)

#  Are an Insert and delete in the same session an atomic transaction?
#  SHACL overhead on the writes
#  Named graph FROM vs FROM NAMED
#  Multi tenancy and row level security
#  Encryption
#  Temporal data 
#  Reasoning on Virtual Graph?
#  With OWL, do I need RDFS at all?





###################################################################################################















# TODO
# Add edge between :product and :customer - who bought which products whithout the need to traverse the whole path above. 
# Can it be done with ontology? try RDFS? Insert tripes returned by the query above? 


# Reasoning
select * where { ?sub rdfs:subClassOf ?super }

# Federated query (Wikibase) - turn off reasoning!
PREFIX wdt: <http://www.wikidata.org/prop/direct/>
PREFIX wd: <http://www.wikidata.org/entity/>
PREFIX wikibase: <http://wikiba.se/ontology#>
PREFIX bd: <http://www.bigdata.com/rdf#>

SELECT * 
WHERE {  
    SERVICE <https://query.wikidata.org/sparql> {
         ?standard wdt:P1462 wd:Q37033 .
        OPTIONAL{ ?standard wdt:P856 ?website }
        SERVICE wikibase:label { bd:serviceParam wikibase:language "en" 
        }
    }
}


# Federated query (Wikibase)
PREFIX wdt: <http://www.wikidata.org/prop/direct/>
PREFIX wd: <http://www.wikidata.org/entity/>
PREFIX wikibase: <http://wikiba.se/ontology#>
PREFIX bd: <http://www.bigdata.com/rdf#>
SELECT ?item ?itemLabel ?_image
WHERE {
  SERVICE <https://query.wikidata.org/sparql> {
    wd:Q7918342 wdt:P279 wd:Q28803.
    SERVICE wikibase:label { bd:serviceParam wikibase:language "en". }
  OPTIONAL { ?item wdt:P18 ?_image. }
  }
}
LIMIT 100


# Show the names of 100 cities with a population larger than 1000000 in the native languages of their countries
PREFIX wdt: <http://www.wikidata.org/prop/direct/>
PREFIX wd: <http://www.wikidata.org/entity/>
PREFIX wikibase: <http://wikiba.se/ontology#>
PREFIX bd: <http://www.bigdata.com/rdf#>

SELECT ?city ?cityLabel ?country ?countryLabel ?lang ?langLabel ?langCode ?population
WHERE {
  SERVICE <https://query.wikidata.org/sparql> {
    ?city wdt:P1082 ?population .
  
    FILTER(?population>1000000)
  
    ?city wdt:P31 wd:Q515;
          wdt:P17 ?country;
          rdfs:label ?cityLabel .
    ?country wdt:P37 ?lang;
            rdfs:label ?countryLabel .
    ?lang wdt:P424 ?langCode;
          rdfs:label ?langLabel .

    FILTER(lang(?cityLabel)=?langCode)
    FILTER(lang(?countryLabel)=?langCode)
    FILTER(lang(?langLabel)=?langCode)
  }
} LIMIT 10