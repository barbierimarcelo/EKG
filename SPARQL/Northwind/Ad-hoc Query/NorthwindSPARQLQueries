

# Selecting all triples
SELECT ?subject ?predicate ?object
WHERE {
  ?subject ?predicate ?object .
}
ORDER BY ?subject


# Simplifying the query by using *, short variables names and omit the period and WHERE clause
SELECT * {?s ?p ?o} ORDER BY ?s


# Triple total count
SELECT (COUNT(?s) as ?numTriples)
WHERE {
    ?s ?p ?o .
}


# Selecting all properties of a Class
SELECT DISTINCT
  ?domain ?prop ?range
WHERE {
    ?subject ?prop ?object .
    ?subject a ?domain .
    optional {
        ?object a ?oClass .
    }
    BIND(IF(bound(?oClass), ?oClass, DATATYPE(?object)) AS ?range)
    FILTER (?prop != rdf:type && ?prop != rdfs:domain && ?prop != rdfs:range && ?domain = :supplier)
}



# Counting class instances
SELECT ?class (COUNT(?subject) as ?classCount)
WHERE {
  ?subject ?predicate ?object .
  ?subject rdf:type ?class .
  FILTER (?class != rdfs:Class && ?class != rdf:Property)
}
GROUP BY ?class
ORDER BY DESC(?classCount)


# Constructing a graph
# On the Visual Graph, select "No Group" in nodes and choose iri for the caption.
CONSTRUCT {
    ?domain ?prop ?range
}
WHERE {
    ?subject ?prop ?object .
    ?subject a ?domain .
    optional {
        ?object a ?oClass .
    }
    bind(if(bound(?oClass), ?oClass, datatype(?object)) as ?range)
    filter (?prop != rdf:type && ?prop != rdfs:domain && ?prop != rdfs:range)
}


# Prefix and namespace
# The next three queries return the same results

# Selecting product details using full URI
SELECT ?p ?o 
WHERE { 
  <http://www.mysparql.com/resource/northwind/product-2> ?p ?o .
}

# Selecting product details using a prefix
PREFIX :<http://www.mysparql.com/resource/northwind/>
SELECT ?p ?o 
WHERE { 
  :product-2 ?p ?o .
} 

# Selecting product details using a database namespace
# An empty prefix has been added for the <http://api.stardog.com/> IRI in the database namespace list. 
SELECT ?p ?o 
WHERE { 
  :product-2 ?p ?o .
} 


# Selecting product names
SELECT ?s ?productName
{ 
	?s a :product .
  ?s   :productName ?productName
}

# Omitting the subject
SELECT ?s ?productName
{ 
	?s a :product ;
       :productName ?productName
}


#Selecting product names and IDs
SELECT 
  ?s 
  ?id 
  ?productName 
WHERE
{ 
  ?s a :product ;
       :productName ?productName ;
       :productID ?id .
} 


# Selecting the unit price of a product using filter
select ?s ?o
{ 
	?s a :product .
    ?s :unitPrice ?o .
    FILTER (?s=:product-1)
}

# Selecting product, category and supplier details (Join) with filter
SELECT 
  ?product 
  ?productLabel 
  ?productName 
  ?unitsInStock 
  ?unitPrice 
  ?categoryName 
  ?contactName
WHERE
{ 
  ?product a  :product ;
              :productName ?productName ;
              :unitsInStock ?unitsInStock ;
              :unitPrice ?unitPrice ;
              rdfs:label ?productLabel ;
              :hasCategory ?category ;
              :hasSupplier ?supplier .
  ?category a :category ;
              :name ?categoryName .
  ?supplier a :supplier ;
              :contactName ?contactName ;
              :country "USA"
} 


# Grouping Data (Quantity of products sold by each Supplier Representative) 
SELECT 
  ?supplierContactName 
  (COUNT(?product) as ?productCount)
WHERE
{ 
  ?product a  :product ;
              :hasSupplier ?supplier .
  ?supplier a :supplier ;
              :contactName ?supplierContactName .
  #FILTER(?supplierContactName = "Charlotte Cooper") .
} 
GROUP BY ?supplierContactName
HAVING (COUNT(?product) > 3)


# Top 5 largest orders in number of products shipped in the USA
SELECT ?order (COUNT(*) as ?itemCount)
WHERE
{ 
	?item  :belongsToOrder ?order .
  ?order :shipCountry ?shipCountry ;
	       :orderID ?orderID .
	FILTER (?shipCountry = "USA") .
} 
GROUP BY ?order 
ORDER BY DESC (?itemCount) ASC (?orderID)
LIMIT 5


# Selecting all properties of "employee" Class
SELECT DISTINCT
  ?domain ?prop ?range
WHERE {
    ?subject ?prop ?object .
    ?subject a ?domain .
    optional {
        ?object a ?oClass .
    }
    BIND(IF(bound(?oClass), ?oClass, DATATYPE(?object)) AS ?range)
    FILTER (?prop != rdf:type && ?prop != rdfs:domain && ?prop != rdfs:range && ?domain = :employee)
}


# Basic select with specified columns
SELECT
  ?emp
  ?label
  ?lastName
  ?firstName
  ?title
WHERE {
  ?emp a :employee .
  ?emp   foaf:lastName ?lastName ;
         foaf:firstName ?firstName ;
         foaf:title ?title ;
         rdfs:label ?label .
}





