
# TODO:
# https://www.stardog.com/tutorials/sparql/
# Complete the series below with examples from the following links:
# https://www.stardog.com/tutorials/getting-started-1/
# https://www.stardog.com/tutorials/similarity-search/
# https://www.w3.org/TR/2013/REC-sparql11-query-20130321/#idp899488


# Selecting all triples
SELECT ?subject ?predicate ?object
WHERE {
  ?subject ?predicate ?object .
}
ORDER BY ?subject


# Simplifying the query by using *, short variables names and omit the period and WHERE clause
SELECT * {?s ?p ?o} ORDER BY ?s
SELECT * {?s :hasProduct ?o} ORDER BY ?s

# Returns all the outgoing edges of the node 
# Check the results in Visual view mode
DESCRIBE :orderDetail-10248-72
DESCRIBE :order-10248
DESCRIBE :product-1


# Total triple count
SELECT (COUNT(?s) as ?numTriples)
WHERE {
    ?s ?p ?o .
}


# Total triple count from virtual graph
SELECT (COUNT(?s) as ?numTriples)
WHERE {
  GRAPH <virtual://nwvg> 
  {
      ?s ?p ?o .
  }
}


# Selecting all properties of a Class
SELECT DISTINCT
  ?domain ?prop ?range
WHERE {
    ?subject ?prop ?object .
    ?subject a ?domain .
    optional {
        ?object a ?oClass .
    }
    BIND(IF(bound(?oClass), ?oClass, DATATYPE(?object)) AS ?range)
    FILTER (?prop != rdf:type && ?prop != rdfs:domain && ?prop != rdfs:range && ?domain = :supplier)
}


# Counting predicates (relationships)
SELECT ?predicate (COUNT(?predicate) as ?predicateCount)
WHERE {
    ?subject ?predicate ?object .
}
GROUP BY ?predicate
ORDER BY DESC(?predicateCount)


# Counting class instances
SELECT ?class (COUNT(?subject) as ?classCount)
WHERE {
  ?subject ?predicate ?object .
  ?subject rdf:type ?class .
  FILTER (?class != rdfs:Class && ?class != rdf:Property)
}
GROUP BY ?class
ORDER BY DESC(?classCount)


# Constructing a graph
# On the Visual Graph, select "No Group" in nodes and choose iri for the caption.
CONSTRUCT {
    ?domain ?prop ?range
}
WHERE {
    ?subject ?prop ?object .
    ?subject a ?domain .
    optional {
        ?object a ?oClass .
    }
    bind(if(bound(?oClass), ?oClass, datatype(?object)) as ?range)
    filter (?prop != rdf:type && ?prop != rdfs:domain && ?prop != rdfs:range)
}


# Prefix and namespace
# The next three queries return the same results

# Selecting product details using full URI
SELECT ?p ?o 
WHERE { 
  <http://www.mysparql.com/resource/northwind/product-2> ?p ?o .
}

# Selecting product details using a prefix
PREFIX :<http://www.mysparql.com/resource/northwind/>
SELECT ?p ?o 
WHERE { 
  :product-2 ?p ?o .
} 

# Selecting product details using a database namespace
# An empty prefix has been added for the <http://api.stardog.com/> IRI in the database namespace list. 
SELECT ?p ?o 
WHERE { 
  :product-2 ?p ?o .
} 


# Selecting product names
SELECT ?s ?productName
{ 
	?s a :product .
  ?s   :productName ?productName
}

# Omitting the subject
SELECT ?s ?productName
{ 
	?s a :product ;
       :productName ?productName
}


#Selecting product names and IDs
SELECT 
  ?s 
  ?id 
  ?productName 
WHERE
{ 
  ?s a :product ;
       :productName ?productName ;
       :productID ?id .
} 


# Selecting the unit price of a product using filter
select ?s ?o
{ 
	?s a :product .
  ?s    :unitPrice ?o .
  FILTER (?s=:product-1)
}

# Selecting product, category and supplier details (Join) with filter
SELECT 
  ?product 
  ?productLabel 
  ?productName 
  ?unitsInStock 
  ?unitPrice 
  ?categoryName 
  ?contactName
WHERE
{ 
  ?product a  :product ;
              :productName ?productName ;
              :unitsInStock ?unitsInStock ;
              :unitPrice ?unitPrice ;
              rdfs:label ?productLabel ;
              :hasCategory ?category ;
              :hasSupplier ?supplier .
  ?category a :category ;
              :name ?categoryName .
  ?supplier a :supplier ;
              :contactName ?contactName ;
              :country "USA" .
} 


# Grouping Data (Quantity of products sold by each Supplier Representative) 
SELECT 
  ?supplierContactName 
  (COUNT(?product) as ?productCount)
WHERE
{ 
  ?product a  :product ;
              :hasSupplier ?supplier .
  ?supplier a :supplier ;
              :contactName ?supplierContactName .
  #FILTER(?supplierContactName = "Charlotte Cooper") .
} 
GROUP BY ?supplierContactName
HAVING (COUNT(?product) > 3)


# Top 5 largest orders in number of products shipped in the USA
SELECT ?order (COUNT(*) as ?itemCount)
WHERE
{ 
	?item  :belongsToOrder ?order .
  ?order :shipCountry ?shipCountry ;
	       :orderID ?orderID .
	FILTER (?shipCountry = "USA") .
} 
GROUP BY ?order 
ORDER BY DESC (?itemCount) ASC (?orderID)
LIMIT 5


# Selecting all properties of "employee" Class
SELECT DISTINCT
  ?domain ?prop ?range
WHERE {
    ?subject ?prop ?object .
    ?subject a ?domain .
    optional {
        ?object a ?oClass .
    }
    BIND(IF(bound(?oClass), ?oClass, DATATYPE(?object)) AS ?range)
    FILTER (?prop != rdf:type && ?prop != rdfs:domain && ?prop != rdfs:range && ?domain = :employee)
}



################################################


# Basic select with specified columns
SELECT
  ?emp
  ?label
  ?lastName
  ?firstName
  ?title
WHERE {
  ?emp a :employee .
  ?emp   rdfs:label ?label ;
         foaf:lastName ?lastName ;
         foaf:firstName ?firstName ;
         foaf:title ?title .
}


# Any employees in the USA? (returns true or false)
ASK {
  ?emp a :employee .
  ?emp   rdfs:label ?label ;
         foaf:lastName ?lastName ;
         foaf:firstName ?firstName ;
         foaf:title ?title ;
         :country "USA" .
}


# Basic select with string match filter
SELECT
  ?emp
  ?label
  ?lastName
  ?firstName
  ?title
WHERE {
  ?emp a :employee .
  ?emp   rdfs:label ?label ;
         foaf:lastName ?lastName ;
         foaf:firstName ?firstName ;
         foaf:title ?title ;
         :country "USA" .
}


# The same filter can be applied as follows
SELECT
  ?emp
  ?label
  ?lastName
  ?firstName
  ?title
WHERE {
  ?emp a :employee .
  ?emp   rdfs:label ?label ;
         foaf:lastName ?lastName ;
         foaf:firstName ?firstName ;
         foaf:title ?title ;
         :country ?country .
  FILTER(?country = "USA")
}


# Character string match (Regex)
SELECT
  ?s # This object variable can be used to visualize the graph in Stardog Studio
  ?companyLabel
  ?companyName
  ?contactName
  ?address
  ?city 
  ?phone 
WHERE {
  ?s a :customer .
  ?s   rdfs:label ?companyLabel ;
       :companyName ?companyName ;
       :contactName ?contactName ;
       :address ?address ;
       :city ?city ;
       :phone ?phone .
  FILTER (REGEX(?companyName, "Rest" , "i" )) # Case Insensitive
}


# Logical Operators, Join and simple type conversion. 
SELECT
  ?productName
  (STR(?unitPrice) AS ?strUnitPrice) # converting integer to string
  ?supplierName
  ?region 
  ?country 
WHERE {
  ?s a :product .
  ?s   :productName ?productName ;
       :productID ?productID ;
       :hasSupplier ?supplier ; # Joining on supplier
       :unitPrice ?unitPrice . 
  # getting supplier properties
  ?supplier :companyName ?supplierName ;  
            :region ?region ;
            :country ?country . 
  FILTER((REGEX(?productName, "^T", "i") || ?productID > 46) && ?unitPrice > 16) . # Logical operators
}


# Data ranges
SELECT
  ?productID
  ?productName
  ?unitPrice
WHERE {
  ?s a :product .
  ?s   :productID ?productID ;
       :productName ?productName ;
       :unitPrice ?unitPrice .
  FILTER (?unitPrice >= 18 && ?unitPrice <= 20)
}


# Filtering on list of values
SELECT
  ?companyName
  ?country
WHERE {
  ?s a :supplier .
  ?s   :companyName ?companyName ;
       :country ?country .
  FILTER (UCASE(?country) = "JAPAN" || ?country = "Italy") # case sensitive
}


# Working with Nulls (next 3 examples)
SELECT
  ?companyName
  ?fax
WHERE {
  ?s a :supplier .
  ?s   :companyName ?companyName ;
       :fax ?fax . # only suppliers with fax
}


SELECT
  ?companyName
  ?fax
WHERE {
  ?s a :supplier .
  ?s   :companyName ?companyName ;
       OPTIONAL {?s :fax ?fax} . # suppliers with and without fax
}


SELECT
  ?companyName
  ?fax
WHERE {
  ?s a :supplier .
  ?s   :companyName ?companyName ;
       OPTIONAL {?s :fax ?fax} . # suppliers without fax
  FILTER (!BOUND(?fax))
}


# Sorting data
SELECT
  ?productID
  ?productName
  ?unitPrice
  ?categoryName
WHERE {
  ?s a :product .
  ?s   :productID ?productID ;
       :productName ?productName ;
       :unitPrice ?unitPrice ;
       :hasCategory ?category .
  ?category :name ?categoryName . # TODO: update this property to :categoryName
}
ORDER BY 
  ASC(?categoryName)
  DESC(?unitPrice)


# Eliminating duplicates
SELECT DISTINCT ?country
WHERE{
  ?s a :supplier .
  ?s   :country ?country .
}
ORDER BY ?country # Default sorting


# Column alias and string manipulation
SELECT
  (?employeeLabel AS ?label)
  (?employeeCode AS ?code)
  ?firstName
  ?lastName
 WHERE {
   ?s a :employee .
   ?s   foaf:firstName ?firstName ;
        foaf:lastName ?lastName ;
        rdfs:label ?employeeLabel ; 
  BIND(CONCAT(?employeeLabel, "-", SUBSTR(?firstName,1,1), SUBSTR(?lastName,1,3)) AS ?employeeCode)
 }


# Limiting results - joining product and order.
# Largest orders of a single product
SELECT
  ?orderID
  ?productID
  ?quantity
WHERE {
  ?orderDetail  a :orderDetail .
  ?orderDetail    :quantity         ?quantity ;
                  :belongsToOrder   ?order ;
                  :hasProduct       ?product .
  ?order          :orderID          ?orderID .
  ?product        :productID        ?productID .
}
ORDER BY DESC(?quantity)
LIMIT 5


# Counting 
SELECT (COUNT(?country) AS ?countryCount)
WHERE{
  ?s a :supplier .
  ?s   :country ?country .
}


# Distinct Count
SELECT (COUNT(DISTINCT ?country) AS ?countryCount)
WHERE{
  ?s a :supplier .
  ?s   :country ?country .
}


# Grouping and Aggregations
# Top 10 most sold products
SELECT
  ?prd
  (SUM(?quantity) AS ?totalQty)  
WHERE {
  ?od a :orderDetail .
  ?od   :quantity ?quantity ;
        :hasProduct ?prd .
}
GROUP BY ?prd
ORDER BY DESC(?totalQty)
LIMIT 10


# Reasoning
select * where { ?sub rdfs:subClassOf ?super }


# Federated query (Wikibase) - turn off reasoning!
PREFIX wdt: <http://www.wikidata.org/prop/direct/>
PREFIX wd: <http://www.wikidata.org/entity/>
PREFIX wikibase: <http://wikiba.se/ontology#>
PREFIX bd: <http://www.bigdata.com/rdf#>

SELECT * 
WHERE {  
    SERVICE <https://query.wikidata.org/sparql> {
         ?standard wdt:P1462 wd:Q37033 .
        OPTIONAL{ ?standard wdt:P856 ?website }
        SERVICE wikibase:label { bd:serviceParam wikibase:language "en" 
        }
    }
}


# Federated query (Wikibase)
PREFIX wdt: <http://www.wikidata.org/prop/direct/>
PREFIX wd: <http://www.wikidata.org/entity/>
PREFIX wikibase: <http://wikiba.se/ontology#>
PREFIX bd: <http://www.bigdata.com/rdf#>
SELECT ?item ?itemLabel ?_image
WHERE {
  SERVICE <https://query.wikidata.org/sparql> {
    ?item wdt:P279 wd:Q28803.
    SERVICE wikibase:label { bd:serviceParam wikibase:language "en". }
  OPTIONAL { ?item wdt:P18 ?_image. }
  }
}
LIMIT 100


# Show the names of 100 cities with a population larger than 1000000 in the native languages of their countries
PREFIX wdt: <http://www.wikidata.org/prop/direct/>
PREFIX wd: <http://www.wikidata.org/entity/>
PREFIX wikibase: <http://wikiba.se/ontology#>
PREFIX bd: <http://www.bigdata.com/rdf#>

SELECT ?city ?cityLabel ?country ?countryLabel ?lang ?langLabel ?langCode ?population
WHERE {
  SERVICE <https://query.wikidata.org/sparql> {
    ?city wdt:P1082 ?population .
  
    FILTER(?population>1000000)
  
    ?city wdt:P31 wd:Q515;
          wdt:P17 ?country;
          rdfs:label ?cityLabel .
    ?country wdt:P37 ?lang;
            rdfs:label ?countryLabel .
    ?lang wdt:P424 ?langCode;
          rdfs:label ?langLabel .

    FILTER(lang(?cityLabel)=?langCode)
    FILTER(lang(?countryLabel)=?langCode)
    FILTER(lang(?langLabel)=?langCode)
  }
} LIMIT 10


# Who bought product A also bought which products? 
# Step by step evolution of the query
SELECT 
  *
WHERE {
  ?orderDetail :belongsToOrder ?order ;
               :hasProduct ?product .
  ?order       :hasCustomer ?customer .
}


SELECT 
  *
WHERE {
  ?product     ^:hasProduct  ?orderDetail .
  ?orderDetail :belongsToOrder ?order .
  ?order       :hasCustomer ?customer .
}


SELECT 
  *
WHERE {
  ?product ^:hasProduct/:belongsToOrder ?order .
  ?order   :hasCustomer ?customer .
}


SELECT DISTINCT
  *
WHERE {
  ?product ^:hasProduct/:belongsToOrder/:hasCustomer ?customer .
 
}


# Who bought product-1 also bought which products?
SELECT 
  ?productA
  ?productB
  (COUNT (*) AS ?productBCount)
WHERE {
  ?productA ^:hasProduct/:belongsToOrder/:hasCustomer/^(^:hasProduct/:belongsToOrder/:hasCustomer) ?productB ;
            :productID ?productID .
  FILTER (?productA != ?productB && ?productA = :product-1)
}
GROUP BY ?productA ?productB
ORDER BY DESC(?productBCount)



# TODO
# Add edge between :product and :customer - who bought which products whithout the need to traverse the whole path above. 
# Can it be done with ontology? try RDFS? Insert tripes returned by the query above? 
#