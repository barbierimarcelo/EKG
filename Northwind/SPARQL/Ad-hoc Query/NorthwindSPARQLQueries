

# Northwind SPARQL Queries


# Basic select with specified columns


# Query: Employee titles 
SELECT
  ?label
  ?lastName
  ?firstName
  ?title
WHERE {
  ?emp a :employee ;
         rdfs:label ?label ;
         foaf:title ?title ;
         foaf:lastName ?lastName ;
         foaf:firstName ?firstName .      
}


# Filtering Data


# Query: List of Employees in the USA
SELECT
  ?label
  ?lastName
  ?firstName
  ?title
WHERE {
  ?emp a :employee ;
         rdfs:label ?label ;
         foaf:lastName ?lastName ;
         foaf:firstName ?firstName ;
         foaf:title ?title ;
         :country ?country .
  FILTER(?country = "USA")
}

# Note: The same filter can be applied directly as follows
SELECT
  ?label
  ?lastName
  ?firstName
  ?title
WHERE {
  ?emp a :employee ;
         rdfs:label ?label ;
         foaf:lastName ?lastName ;
         foaf:firstName ?firstName ;
         foaf:title ?title ;
         :country "USA" .
}


# Returns a boolean indicating whether a query pattern matches or not.
# Query: Do I have any employees in the UK?
ASK {
  ?emp a :employee ;
         :country "UK" .
}



# Using string comparison


# Character search pattern (Regex)
# Query: Companies that contain the word "Rest" in their names.
SELECT
  ?companyName
  ?contactName
  ?address
  ?city 
  ?phone 
WHERE {
  ?s a :customer ;
       rdfs:label ?companyLabel ;
       :companyName ?companyName ;
       :contactName ?contactName ;
       :address ?address ;
       :city ?city ;
       :phone ?phone .
  FILTER (REGEX(?companyName, "Rest" , "i" )) # Case Insensitive
}


# Joins


# Query: Selecting details of products supplied by companies located in the USA
# Joining product, category and supplier. 
SELECT 
  ?productID 
  ?productName 
  ?unitsInStock 
  ?unitPrice 
  ?categoryName 
  ?contactName
WHERE
{ 
  ?product a  :product ;
              :productID ?productID ;
              :productName ?productName ;
              :unitsInStock ?unitsInStock ;
              :unitPrice ?unitPrice ;
              :hasCategory ?category ;
              :hasSupplier ?supplier .
  ?category a :category ;
              :name ?categoryName .
  ?supplier a :supplier ;
              :contactName ?contactName ;
              :country "USA" .
} 


# Query: Customers who placed at least one order
SELECT DISTINCT 
  ?customer
  ?companyName
  ?postalCode
  ?city
  ?country 
WHERE {
  ?order    a :order .
  ?customer a :customer .
  ?order      :hasCustomer ?customer .
  ?customer   :customerID ?customerID ;
              :companyName ?companyName ;
              :city ?city ;
              :country ?country .
  OPTIONAL {?customer :postalCode ?postalCode} . # Some regions don't use PostalCode.
}
ORDER BY
  ?customer


# Query: Customers who never placed an order
SELECT DISTINCT 
  ?customer
  ?companyName
  ?postalCode
  ?city
  ?country
WHERE {
  ?customer a :customer .
  ?customer   :customerID ?customerID ;
              :companyName ?companyName ;
              :city ?city ;
              :country ?country .
  OPTIONAL {?customer :postalCode ?postalCode} . # Some regions don't use PostalCode.
  OPTIONAL {
    ?order a  :order .
    ?customer ^:hasCustomer ?order # left join - for customers with no orders, ?order variable will be empty.
  } 
  FILTER (!BOUND(?order)) # Checks if variable is not bound to a value. 
}
ORDER BY
  ?customer


# Using Logical Operators


# Query: Search specific products
# All products with product names that begin with the letter T or have a product 
# identification number of 46 and that have a price greater than $16.00.
SELECT
  ?productName
  (STR(?unitPrice) AS ?strUnitPrice) # converting integer to string
  ?supplierName
  ?region 
  ?country 
WHERE {
  ?s a :product ;
       :productName ?productName ;
       :productID ?productID ;
       :hasSupplier ?supplier ; # Joining on supplier
       :unitPrice ?unitPrice . 
  # getting supplier properties
  ?supplier :companyName ?supplierName ;  
            :country ?country ; 
  OPTIONAL {?supplier  :region ?region }. # not all suppliers have region
  FILTER((REGEX(?productName, "^T", "i")) || (?productID = 46 && ?unitPrice > 16)) . # Logical operators
}


# Filtering on Data ranges


# Query: Products in specified price range
# Retrieves products with a unit price between $10.00 and $20.00.
SELECT
  ?productName
  ?companyName
  ?unitPrice
WHERE {
  ?s a :product ;
       :productID ?productID ;
       :productName ?productName ;
       :hasSupplier ?supplier ; 
       :unitPrice ?unitPrice .
  ?supplier a :supplier ;
       :companyName ?companyName ;
       :supplierID ?supplierID .
  FILTER (?unitPrice >= 18 && ?unitPrice <= 20) 
}


# Filtering on list of values


# Query: List of suppliers that are located in Japan or Italy
SELECT
  ?companyName
  ?country
WHERE {
  ?s a :supplier ;
       :companyName ?companyName ;
       :country ?country .
  FILTER (UCASE(?country) = "JAPAN" || ?country = "Italy") # case sensitive
}


# Working with Nulls


# Query: Select only suppliers that have a fax number
# Note: Fax was a machine from the 90s able to scan and transmit a document over the phone line.
SELECT
  ?companyName
  ?fax
WHERE {
  ?s a :supplier ;
       :companyName ?companyName ;
       :fax ?fax . 
}


# Query: Select all suppliers
SELECT
  ?companyName
  ?fax
WHERE {
  ?s a :supplier ;
       :companyName ?companyName ;
       OPTIONAL {?s :fax ?fax} . 
}


# Query: Select only suppliers that don't have a fax number
SELECT
  ?companyName
  ?fax
WHERE {
  ?s a :supplier ;
       :companyName ?companyName ;
       OPTIONAL {?s :fax ?fax} . 
  FILTER (!BOUND(?fax))
}


# Sorting data


# Query: Sort products in each product category by unit price descending
SELECT
  ?productName
  ?categoryName
  ?unitPrice
WHERE {
  ?s a :product ;
       :productID ?productID ;
       :productName ?productName ;
       :unitPrice ?unitPrice ;
       :hasCategory ?category .
  ?category :name ?categoryName . 
}
ORDER BY 
  ASC(?categoryName)
  DESC(?unitPrice)


# Eliminating duplicates


# Query: Select all countries I buy from
# Note that there are more than one supplier per country and DISTINCT has been used to eliminate the duplicates.
SELECT DISTINCT ?country
WHERE{
  ?s a :supplier ;
       :country ?country .
}
ORDER BY ?country # Default sorting


# Column alias and string concatenation


# Query: Create employee code
SELECT
  (CONCAT (?firstName, " ", ?lastName) AS ?fullName)
  ?code
 WHERE {
   ?s a :employee ;
        foaf:firstName ?firstName ;
        foaf:lastName ?lastName ;
        rdfs:label ?employeeLabel ; 
        :extension ?extension ;
        :country ?country ;
  OPTIONAL {?s :region ?region } .
  BIND(CONCAT(SUBSTR(?firstName,1,1), SUBSTR(?lastName,1,3), "-", ?extension, "-", IF(!BOUND(?region), 
       CONCAT("INT-", ?country), ?region)) AS ?code)
 }
 ORDER BY ?lastName


# Limiting results


# Joins product, order, and orderDetail
# Query: Top 5 largest quantity of a product sold in a single order
SELECT
    ?productName
    ?orderID
    ?orderDate
    ?quantity
    ?unitsInStock
WHERE {
  ?orderDetail  a :orderDetail .
  ?order        a :order .
  ?product      a :product .
  ?orderDetail    :quantity         ?quantity ;
                  :belongsToOrder   ?order ;
                  :hasProduct       ?product .
  ?order          :orderID          ?orderID ;
                  :orderDate        ?orderDate .
  ?product        :unitsInStock     ?unitsInStock ;
                  :productName      ?productName .
}
ORDER BY 
  DESC(?quantity)
  DESC(?orderDate)
LIMIT 5


# Pagination


# Query: Retrieve records from 6 to 10 from list of largest quantity of a product sold in a single order
SELECT
    ?productName
    ?orderID
    ?orderDate
    ?quantity
    ?unitsInStock
WHERE {
  ?orderDetail  a :orderDetail .
  ?order        a :order .
  ?product      a :product .
  ?orderDetail    :quantity         ?quantity ;
                  :belongsToOrder   ?order ;
                  :hasProduct       ?product .
  ?order          :orderID          ?orderID ;
                  :orderDate        ?orderDate .
  ?product        :unitsInStock     ?unitsInStock ;
                  :productName      ?productName .
}
ORDER BY 
  DESC(?quantity)
  DESC(?orderDate)
OFFSET 5
LIMIT 5


# Counting


# Query: Number of supplier
SELECT (COUNT(1) AS ?supplierCount)
WHERE{
  ?s a :supplier .
}


# Distinct Counting


# Query: Number of countries I buy from.
SELECT (COUNT(DISTINCT ?country) AS ?countryCount)
WHERE{
  ?s a :supplier ;
       :country ?country .
}


# Grouping and Aggregating data


# Query: Top 5 most sold products
SELECT
  ?productID
  (SUM(?quantity) AS ?totalQtySold)  
WHERE {
  ?order a :orderDetail ;
           :quantity ?quantity ;
           :hasProduct ?product .
  ?product :productID ?productID .
}
GROUP BY ?productID
ORDER BY DESC(?totalQtySold)
LIMIT 5


# Query: Top 5 largest orders shipped to the USA
SELECT
  ?orderID
  (ROUND(SUM(?unitPrice * ?quantity * (1 - ?discount))) AS ?total) 
WHERE {
  ?order        a :order ;
                  :orderID ?orderID ;
                  :shipCountry "USA" .
  ?orderDetail  a :orderDetail ;
                  :belongsToOrder ?order ;
                  :unitPrice ?unitPrice ;
                  :quantity ?quantity ;
                  :discount ?discount .
}
GROUP BY
  ?orderID
ORDER BY 
  DESC(?total)
LIMIT 5


# Query: Orders over 10K shipped to the USA 
SELECT
  ?orderID
  (ROUND(SUM(?unitPrice * ?quantity * (1 - ?discount))) AS ?total)
WHERE {
  ?order        a :order ;
                  :orderID ?orderID ;
                  :shipCountry "USA" .
  ?orderDetail  a :orderDetail ;
                  :belongsToOrder ?order ;
                  :unitPrice ?unitPrice ;
                  :quantity ?quantity ;
                  :discount ?discount .
}
GROUP BY
  ?orderID
HAVING (SUM(?unitPrice * ?quantity * (1 - ?discount)) > 10000)
ORDER BY 
  DESC(?total)


# Query: Top 5 Supplier Representative by number of products sold
SELECT 
  ?supplierContactName 
  (COUNT(?product) as ?productCount)
WHERE
{ 
  ?product a  :product ;
              :hasSupplier ?supplier .
  ?supplier a :supplier ;
              :contactName ?supplierContactName .
} 
GROUP BY 
  ?supplierContactName
ORDER BY
  DESC(?productCount)
LIMIT 5



# Recommendation - Products frequently bought together


# Query: Customers who bought product-61 also bought which products in the same order?
SELECT 
  ?productA
  ?productB
  (COUNT (*) AS ?productBCount)
WHERE {
  ?productA ^:hasProduct/:belongsToOrder/^(^:hasProduct/:belongsToOrder) ?productB ;
             :productID ?productID .
  FILTER (?productA != ?productB && ?productA = :product-61) # Filtering on product-61 for testing
}
GROUP BY ?productA ?productB 
ORDER BY DESC(?productBCount) ?productA ?productB # Most frequent at the top


# Query: Customers who bought product-61 also bought which products across all orders?
SELECT 
  ?productA
  ?productB
  (COUNT (*) AS ?productBCount)
WHERE {
  ?productA ^:hasProduct/:belongsToOrder/:hasCustomer/^(^:hasProduct/:belongsToOrder/:hasCustomer) ?productB ;
            :productID ?productID .
  FILTER (?productA != ?productB && ?productA = :product-61) # Filtering on product-61 for testing purposes
}
GROUP BY ?productA ?productB
ORDER BY DESC(?productBCount) ?productA ?productB


# Query: Number of times products 2 and 61 where bought by the same customer
SELECT (COUNT (1) AS ?Count)
WHERE {:product-2 ^:hasProduct/:belongsToOrder/:hasCustomer/^(^:hasProduct/:belongsToOrder/:hasCustomer) :product-61}


# The folloiwng are the 6 steps taken to develop the query above.
# For more details on Property Path, please refer to https://www.stardog.com/tutorials/sparql/#toc7.

# Step 1: Triple pattern matching order, orderDetail, product and customer nodes that are directly connected. 
# List order items that contain product-61
SELECT *
WHERE {
  ?orderDetail :hasProduct ?product ; 
               :belongsToOrder ?order .
  ?order       :hasCustomer ?customer .
  FILTER (?product = :product-61)
}

# Step 2: Invert the hasProduct path expression to match the following direction: 
# product --> orderDetail --> order --> customer
# The same result is returned
SELECT *
WHERE {
  ?product     ^:hasProduct  ?orderDetail . # Invert direction
  ?orderDetail :belongsToOrder ?order .
  ?order       :hasCustomer ?customer .
  FILTER (?product = :product-61)
}

# Step 3: Use a sequence path to omit the binding of the ?orderDetail variable.  
SELECT *
WHERE {
  ?product ^:hasProduct/:belongsToOrder ?order .
  ?order   :hasCustomer ?customer .
  FILTER (?product = :product-61)
}

# Step 4: Use a sequence path to omit the binding of the ?order varaible.
# All customers that bought product-61
SELECT DISTINCT * # eliminates duplicates in case the same customer bouth a product more than once
WHERE {
  ?product ^:hasProduct/:belongsToOrder/:hasCustomer ?customer .
  FILTER (?product = :product-61)
}
ORDER BY ?product

# Step 5: Remove the ?product variable and apply the filter directly to the subject. 
SELECT DISTINCT * # eliminates duplicates in case the same customer bouth a product more than once
WHERE {
  :product-61 ^:hasProduct/:belongsToOrder/:hasCustomer ?customer .
}
ORDER BY ?product

# Step 6: And finally, omit the binding of the ?customer varaible and invert the full path back to product.  
SELECT (COUNT (1) AS ?Count)
WHERE {:product-2 ^:hasProduct/:belongsToOrder/:hasCustomer/^(^:hasProduct/:belongsToOrder/:hasCustomer) :product-61}


# Combining multiple result sets using Union


# Query: Contact details of suppliers, customers and employees for Xmas cards
SELECT
  ?contactName ?address ?city ?postalCode ?country
WHERE {
  {
    ?supplier a :supplier ;
      :contactName ?contactName ;
      :address ?address ;
      :city ?city ;
      :postalCode ?postalCode ;
      :country ?country .
  }
  UNION
  {
    ?customer a :customer ;
      :contactName ?contactName ;
      :address ?address ;
      :city ?city ;
      :postalCode ?postalCode ;
      :country ?country .
  }
   UNION
  {
    ?employee a :employee ;
      foaf:firstName ?firstName ;
      foaf:lastName ?lastName ;
      :address ?address ;
      :city ?city ;
      :postalCode ?postalCode ;
      :country ?country .
    BIND (CONCAT (?firstName, " ", ?lastName) AS ?contactName)
  }
}


# Subqueries


# Query: Select all products that belong to the Seafood category
SELECT
  ?productName
  ?unitPrice
  ?unitsInStock
WHERE { # outer query
  ?product a :product ;
             :productName ?productName ;
             :unitPrice ?unitPrice ;
             :unitsInStock ?unitsInStock ;
             :hasCategory ?category . 
    { # inner query
      SELECT 
        ?category
      WHERE {
        ?category a :category ;
                    :categoryID ?categoryID ;
                    :name "Seafood" .
      }
    }
  }
  ORDER BY
    ?productName



# Correlated subqueries are not supported in SPARQL, and therefore, the following query doesn't produce the expected result.
# https://github.com/w3c/sparql-12/issues/100
# Query: Select the 3 most recent orders from each customer
SELECT DISTINCT 
  *
WHERE { # outer query
  ?customer a :customer ;
              :customerID ?customerID ;
              :city ?city ;
              ^:hasCustomer ?order .
  { # inner query
    SELECT
        ?order
    WHERE {
      ?order a :order ;
               :orderID ?orderID ;
               :orderDate ?orderDate ;
               :hasCustomer ?customer .
    }
      ORDER BY
        DESC(?orderDate)
      LIMIT 3
    }
  }
ORDER BY
  ?customerID 
  ?city 
  DESC(?orderDate)


# A solution could be to run the following query for each customer in a loop and union the result sets in the end.
# However, there is no recursion in SPARQL, either. Only way to solve this is to code it in the application.
SELECT *
WHERE {
  ?orderDetail :hasProduct ?product ; 
               :belongsToOrder ?order .
  ?order       :hasCustomer ?customer ;
               :orderDate ?orderDate .
  FILTER (?customer = :customer-ALFKI)
}
ORDER BY
  ?customer
  DESC(?orderDate)
LIMIT 3




###################################### TODO ######################################
# ADD THE REMAINING SUBQUERIES IN SQL HERE!
# ALSO, The Window Functions

# SPARQL 1.1 doesn't support:
# Correlated subqueries
# Window Functions: compute aggregated values such as moving averages, cumulative aggregates, running totals, or a top N numbering and ranking per group results.
# Recursion operator
# Error handling




# Inserting and updating data


# Query: Insert a new customer
INSERT DATA {
  :customer-AAAAA a :customer ;
  rdfs:label "customer-AAAAA" ;
  :customerID "AAAAA" ;
  :companyName "agnos" ;
  :contactName "Jacobus Geluk" ;
  :contactTitle "CTO" ;
  :address "Abbey Road" ;
  :city "London" .
}

# Checking if new customer has been added successfully
DESCRIBE :customer-AAAAA     


# Query: Update existing customer 
# In SQL you can just update multiple colums of a record in a single update statement. 
# However, in SPARQL, we will need to do this in two steps.

# Step 1: Insert new triple for for the properties not included in Query 23
INSERT DATA {
  :customer-AAAAA a :customer ;
  :country "UK" ;
  :postalCode "SW1A 2AA" . 
}

# Step 2: Update the property values added in Query 23. 
DELETE {
  :customer-AAAAA :address ?oldAddress 
}
INSERT {
  :customer-AAAAA :address ?newAddress
}
WHERE {
  :customer-AAAAA a :customer ;
  :address ?oldAddress ;
  BIND("10 Downing Road" AS ?newAddress) .
}



# TODO:


# Update employee to add employeeID property.
# SHACL - a couple of simple constraints.
# Inserts that break SHACK constraints
# Federated query
# Property Path - need to find useful use cases in Northwind
# Importing data from virtual graph - sales of product 77 missing....
# Check commands to cover from here: https://www.w3.org/TR/sparql11-query/#WritingSimpleQueries
# OWL - a couple of simple properties, e.g. inverse property and inference.
# Trial Graph UIs
# ontotext GraphDB
# Hierarquical data
# Running totals
# Examples in https://www.w3.org/TR/sparql11-query/#OptionalMatching
# RDF*
# Temporal Data
# ETL
# PIVOT and UNPIVOT data (N/A, useful in tabular data)
# Are an Insert and delete in the same session an atomic transaction?
# SHACL overhead on the writes
# Named graph FROM vs FROM NAMED
# Multi tenancy and row level security
# Encryption
# https://www.stardog.com/tutorials/sparql/
# Complete the series below with examples from the following links:
# https://www.stardog.com/tutorials/getting-started-1/
# https://www.stardog.com/tutorials/similarity-search/
# https://www.w3.org/TR/2013/REC-sparql11-query-20130321/#idp899488


# SQL Features
# INTERSECT and EXCEPT
# 
# Add edge between :product and :customer - who bought which products whithout the need to traverse the whole path above. 
# Can it be done with ontology? try RDFS? Insert tripes returned by the query above? 


# Reasoning
select * where { ?sub rdfs:subClassOf ?super }


# U.S National Library of Medicine (MeSH) Sparql endpoint 
prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
SELECT *
WHERE{
    SERVICE <http://id.nlm.nih.gov/mesh/sparql> { 
        <http://id.nlm.nih.gov/mesh/Q000302> ?p ?o .
        FILTER(STR(?p) = "http://www.w3.org/2000/01/rdf-schema#label")
    } 
}



# Federated query (Wikibase) - turn off reasoning!
PREFIX wdt: <http://www.wikidata.org/prop/direct/>
PREFIX wd: <http://www.wikidata.org/entity/>
PREFIX wikibase: <http://wikiba.se/ontology#>
PREFIX bd: <http://www.bigdata.com/rdf#>

SELECT * 
WHERE {  
    SERVICE <https://query.wikidata.org/sparql> {
         ?standard wdt:P1462 wd:Q37033 .
        OPTIONAL{ ?standard wdt:P856 ?website }
        SERVICE wikibase:label { bd:serviceParam wikibase:language "en" 
        }
    }
}


# Federated query (Wikibase)
PREFIX wdt: <http://www.wikidata.org/prop/direct/>
PREFIX wd: <http://www.wikidata.org/entity/>
PREFIX wikibase: <http://wikiba.se/ontology#>
PREFIX bd: <http://www.bigdata.com/rdf#>
SELECT ?item ?itemLabel ?_image
WHERE {
  SERVICE <https://query.wikidata.org/sparql> {
    wd:Q7918342 wdt:P279 wd:Q28803.
    SERVICE wikibase:label { bd:serviceParam wikibase:language "en". }
  OPTIONAL { ?item wdt:P18 ?_image. }
  }
}
LIMIT 100


# Show the names of 100 cities with a population larger than 1000000 in the native languages of their countries
PREFIX wdt: <http://www.wikidata.org/prop/direct/>
PREFIX wd: <http://www.wikidata.org/entity/>
PREFIX wikibase: <http://wikiba.se/ontology#>
PREFIX bd: <http://www.bigdata.com/rdf#>

SELECT ?city ?cityLabel ?country ?countryLabel ?lang ?langLabel ?langCode ?population
WHERE {
  SERVICE <https://query.wikidata.org/sparql> {
    ?city wdt:P1082 ?population .
  
    FILTER(?population>1000000)
  
    ?city wdt:P31 wd:Q515;
          wdt:P17 ?country;
          rdfs:label ?cityLabel .
    ?country wdt:P37 ?lang;
            rdfs:label ?countryLabel .
    ?lang wdt:P424 ?langCode;
          rdfs:label ?langLabel .

    FILTER(lang(?cityLabel)=?langCode)
    FILTER(lang(?countryLabel)=?langCode)
    FILTER(lang(?langLabel)=?langCode)
  }
} LIMIT 10